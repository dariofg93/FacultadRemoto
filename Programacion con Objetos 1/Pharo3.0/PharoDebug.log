THERE_BE_DRAGONS_HERE
Error: Month out of bounds: 16.
23 March 2015 5:08:13.800794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

Date class>>readFrom:
	Receiver: Date
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		day: 	nil
		month: 	nil
		year: 	nil
		parsedNumber: 	16
		prefix: 	1
	Receiver's instance variables: 
		superclass: 	Timespan
		methodDict: 	a MethodDictionary(#addDays:->Date>>#addDays: #addMonths:->Date>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Date
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


Date class>>fromString:
	Receiver: Date
	Arguments and temporary variables: 
		aString: 	'16/11/1993'
	Receiver's instance variables: 
		superclass: 	Timespan
		methodDict: 	a MethodDictionary(#addDays:->Date>>#addDays: #addMonths:->Date>>#a...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Date
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection(ChronologyConstants)
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Chronology'
		traitComposition: 	{}
		localSelectors: 	nil


ByteString(String)>>asDate
	Receiver: '16/11/1993'
	Arguments and temporary variables: 

	Receiver's instance variables: 
'16/11/1993'

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'((''16/11/1993'') asDate) year - (Date today) year'
		itsSelection: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'
		itsSelectionString: 	'((''16/11/1993'') asDate) year - (Date today) year'
	Receiver's instance variables: 
		ast: 	DoIt
	^ '16/11/1993' asDate year - Date today year
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(49 to: 48)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@18)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@18)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(49 to: 48)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#printIt
		otherTarget: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(306446336) a PluggableTextMorph(40...etc...
		bindings: 	nil
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#crlf
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(844627968)'Print it'
	Arguments and temporary variables: 
		evt: 	[(87@297) mouseUp 17956619 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(6.0@287.0) corner: (149.0@305.0)
		owner: 	a MenuMorph(336330752)
		submorphs: 	#()
		fullBounds: 	(6.0@287.0) corner: (149.0@305.0)
		color: 	Color black
		extension: 	a MorphExtension (867958784)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Print it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#printIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'p'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(844627968)'Print it'
	Arguments and temporary variables: 
		evt: 	[(87@297) mouseUp 17956619 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(6.0@287.0) corner: (149.0@305.0)
		owner: 	a MenuMorph(336330752)
		submorphs: 	#()
		fullBounds: 	(6.0@287.0) corner: (149.0@305.0)
		color: 	Color black
		extension: 	a MorphExtension (867958784)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Print it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#printIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'p'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(844627968)'Print it'
	Arguments and temporary variables: 
		evt: 	[(87@297) mouseUp 17956619 nil]
	Receiver's instance variables: 
		bounds: 	(6.0@287.0) corner: (149.0@305.0)
		owner: 	a MenuMorph(336330752)
		submorphs: 	#()
		fullBounds: 	(6.0@287.0) corner: (149.0@305.0)
		color: 	Color black
		extension: 	a MorphExtension (867958784)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Print it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#printIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'p'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(844627968)'Print it'
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
	Receiver's instance variables: 
		bounds: 	(6.0@287.0) corner: (149.0@305.0)
		owner: 	a MenuMorph(336330752)
		submorphs: 	#()
		fullBounds: 	(6.0@287.0) corner: (149.0@305.0)
		color: 	Color black
		extension: 	a MorphExtension (867958784)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Print it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#printIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'p'


MouseButtonEvent>>sentTo:
	Receiver: [(87@297) mouseUp 17956619 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(844627968)'Print it'
	Receiver's instance variables: 
		timeStamp: 	17956619
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(87@297)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(844627968)'Print it'
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
	Receiver's instance variables: 
		bounds: 	(6.0@287.0) corner: (149.0@305.0)
		owner: 	a MenuMorph(336330752)
		submorphs: 	#()
		fullBounds: 	(6.0@287.0) corner: (149.0@305.0)
		color: 	Color black
		extension: 	a MorphExtension (867958784)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Print it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#printIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'p'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		aMorph: 	a ToggleMenuItemMorph(844627968)'Print it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		aMorph: 	a ToggleMenuItemMorph(844627968)'Print it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(844627968)'Print it'
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(6.0@287.0) corner: (149.0@305.0)
		owner: 	a MenuMorph(336330752)
		submorphs: 	#()
		fullBounds: 	(6.0@287.0) corner: (149.0@305.0)
		color: 	Color black
		extension: 	a MorphExtension (867958784)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Print it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#printIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'p'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		aMorph: 	a MenuMorph(336330752)
		localEvt: 	[(87@297) mouseUp 17956619 nil]
		index: 	2
		child: 	a ToggleMenuItemMorph(844627968)'Print it'
		morphs: 	an Array(a ToggleMenuItemMorph(704118784)'Do it' a ToggleMenuItemMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		aMorph: 	a MenuMorph(336330752)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(336330752)
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1.0@263.0) corner: (154.0@603.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(704118784)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(1.0@263.0) corner: (154.0@603.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (395837440) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(844627968)'Print it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(704118784)'Do it' a Toggl...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(336330752)
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
	Receiver's instance variables: 
		bounds: 	(1.0@263.0) corner: (154.0@603.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(704118784)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(1.0@263.0) corner: (154.0@603.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (395837440) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(844627968)'Print it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(704118784)'Do it' a Toggl...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(336330752)
	Arguments and temporary variables: 
		evt: 	[(87@297) mouseUp 17956619 nil]
	Receiver's instance variables: 
		bounds: 	(1.0@263.0) corner: (154.0@603.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(704118784)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(1.0@263.0) corner: (154.0@603.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (395837440) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(844627968)'Print it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(704118784)'Do it' a Toggl...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		focusHolder: 	a MenuMorph(336330752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(86@298) corner: (102@314)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(86@298) corner: (102@314)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@298) mouseOver nil nil]
		targetOffset: 	(81.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17956900 86 298 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(87@297) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	(0@0) corner: (1280@658)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		focusHolder: 	a MenuMorph(336330752)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(86@298) corner: (102@314)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(86@298) corner: (102@314)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@298) mouseOver nil nil]
		targetOffset: 	(81.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17956900 86 298 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		focusHolder: 	a MenuMorph(336330752)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(86@298) corner: (102@314)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(86@298) corner: (102@314)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@298) mouseOver nil nil]
		targetOffset: 	(81.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17956900 86 298 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
	Receiver's instance variables: 
		bounds: 	(86@298) corner: (102@314)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(86@298) corner: (102@314)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@298) mouseOver nil nil]
		targetOffset: 	(81.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17956900 86 298 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(87@297) mouseUp 17956619 nil]
		evt: 	[(87@297) mouseUp 17956619 nil]
	Receiver's instance variables: 
		bounds: 	(86@298) corner: (102@314)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(86@298) corner: (102@314)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@298) mouseOver nil nil]
		targetOffset: 	(81.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17956900 86 298 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(87@297) mouseUp 17956619 nil]
		evtBuf: 	#(1 17956619 87 297 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(86@298) corner: (102@314)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(86@298) corner: (102@314)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@298) mouseOver nil nil]
		targetOffset: 	(81.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17956900 86 298 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	660201
		lastStepMessage: 	nil
		lastCycleTime: 	660200
		alarms: 	a Heap()
		lastAlarmTime: 	660201
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	660201
		lastStepMessage: 	nil
		lastCycleTime: 	660200
		alarms: 	a Heap()
		lastAlarmTime: 	660201
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	660201
		lastStepMessage: 	nil
		lastCycleTime: 	660200
		alarms: 	a Heap()
		lastAlarmTime: 	660201
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	660201
		lastStepMessage: 	nil
		lastCycleTime: 	660200
		alarms: 	a Heap()
		lastAlarmTime: 	660201
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
Date class>>readFrom:
Date class>>fromString:
ByteString(String)>>asDate
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
PrimitiveFailed: primitive #basicNew: in Array class failed
23 March 2015 6:37:22.643794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

Array class(Object)>>primitiveFailed:
	Receiver: Array
	Arguments and temporary variables: 
		selector: 	#basicNew:
	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


Array class(Object)>>primitiveFailed
	Receiver: Array
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


Array class(Behavior)>>basicNew:
	Receiver: Array
	Arguments and temporary variables: 
		sizeRequested: 	[ :x :y | x abc < y abc ]
	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


Array class>>new:
	Receiver: Array
	Arguments and temporary variables: 
		sizeRequested: 	[ :x :y | x abc < y abc ]
	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


SortedCollection class(OrderedCollection class)>>new:
	Receiver: SortedCollection
	Arguments and temporary variables: 
		anInteger: 	[ :x :y | x abc < y abc ]
	Receiver's instance variables: 
		superclass: 	OrderedCollection
		methodDict: 	a MethodDictionary(#=->SortedCollection>>#= #add:->SortedCollection...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#('sortBlock')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SortedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	nil
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


MuchasPersonas>>initialize
	Receiver: a MuchasPersonas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		personas: 	nil


MuchasPersonas class(Behavior)>>new
	Receiver: MuchasPersonas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#initialize->MuchasPersonas>>#initialize )
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#personas)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MuchasPersonas
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica1Obj2
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'hola:= MuchasPersonas new.'
		itsSelection: 	a Text for 'hola:= MuchasPersonas new.'
		itsSelectionString: 	'hola:= MuchasPersonas new.'
	Receiver's instance variables: 
		ast: 	DoIt
	^ hola := MuchasPersonas new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@130)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@130)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 318)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#doIt
		otherTarget: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(306446336) a PluggableTextMorph(40...etc...
		bindings: 	a Dictionary(#braian->a Persona #dario->a Persona #german->a Persona ...etc...
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#crlf
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(214171648)'Do it'
	Arguments and temporary variables: 
		evt: 	[(208@316) mouseUp 23305410 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(160.0@305.0) corner: (303.0@323.0)
		owner: 	a MenuMorph(421265408)
		submorphs: 	#()
		fullBounds: 	(160.0@305.0) corner: (303.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (243531776)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(214171648)'Do it'
	Arguments and temporary variables: 
		evt: 	[(208@316) mouseUp 23305410 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(160.0@305.0) corner: (303.0@323.0)
		owner: 	a MenuMorph(421265408)
		submorphs: 	#()
		fullBounds: 	(160.0@305.0) corner: (303.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (243531776)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(214171648)'Do it'
	Arguments and temporary variables: 
		evt: 	[(208@316) mouseUp 23305410 nil]
	Receiver's instance variables: 
		bounds: 	(160.0@305.0) corner: (303.0@323.0)
		owner: 	a MenuMorph(421265408)
		submorphs: 	#()
		fullBounds: 	(160.0@305.0) corner: (303.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (243531776)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(214171648)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
	Receiver's instance variables: 
		bounds: 	(160.0@305.0) corner: (303.0@323.0)
		owner: 	a MenuMorph(421265408)
		submorphs: 	#()
		fullBounds: 	(160.0@305.0) corner: (303.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (243531776)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MouseButtonEvent>>sentTo:
	Receiver: [(208@316) mouseUp 23305410 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(214171648)'Do it'
	Receiver's instance variables: 
		timeStamp: 	23305410
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(208@316)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(214171648)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
	Receiver's instance variables: 
		bounds: 	(160.0@305.0) corner: (303.0@323.0)
		owner: 	a MenuMorph(421265408)
		submorphs: 	#()
		fullBounds: 	(160.0@305.0) corner: (303.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (243531776)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		aMorph: 	a ToggleMenuItemMorph(214171648)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		aMorph: 	a ToggleMenuItemMorph(214171648)'Do it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(214171648)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(160.0@305.0) corner: (303.0@323.0)
		owner: 	a MenuMorph(421265408)
		submorphs: 	#()
		fullBounds: 	(160.0@305.0) corner: (303.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (243531776)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		aMorph: 	a MenuMorph(421265408)
		localEvt: 	[(208@316) mouseUp 23305410 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(214171648)'Do it'
		morphs: 	an Array(a ToggleMenuItemMorph(214171648)'Do it' a ToggleMenuItemMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		aMorph: 	a MenuMorph(421265408)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(421265408)
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(155.0@300.0) corner: (308.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(214171648)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(155.0@300.0) corner: (308.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (456654848) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(214171648)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(214171648)'Do it' a Toggl...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(421265408)
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
	Receiver's instance variables: 
		bounds: 	(155.0@300.0) corner: (308.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(214171648)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(155.0@300.0) corner: (308.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (456654848) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(214171648)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(214171648)'Do it' a Toggl...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(421265408)
	Arguments and temporary variables: 
		evt: 	[(208@316) mouseUp 23305410 nil]
	Receiver's instance variables: 
		bounds: 	(155.0@300.0) corner: (308.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(214171648)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(155.0@300.0) corner: (308.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (456654848) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(214171648)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(214171648)'Do it' a Toggl...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		focusHolder: 	a MenuMorph(421265408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(230@361) corner: (246@377)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(230@361) corner: (246@377)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(230@361) mouseOver nil nil]
		targetOffset: 	(48.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23305816 230 361 0 0 1 1)
		lastKeyScanCode: 	4
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(208@316) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	(0@0) corner: (1280@658)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		focusHolder: 	a MenuMorph(421265408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(231@365) corner: (247@381)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@365) corner: (247@381)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@365) mouseOver nil nil]
		targetOffset: 	(48.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23305831 231 365 0 0 1 1)
		lastKeyScanCode: 	4
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
		focusHolder: 	a MenuMorph(421265408)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(231@365) corner: (247@381)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@365) corner: (247@381)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@365) mouseOver nil nil]
		targetOffset: 	(48.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23305831 231 365 0 0 1 1)
		lastKeyScanCode: 	4
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(208@316) mouseUp 23305410 nil]
	Receiver's instance variables: 
		bounds: 	(231@365) corner: (247@381)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(231@365) corner: (247@381)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(231@365) mouseOver nil nil]
		targetOffset: 	(48.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23305831 231 365 0 0 1 1)
		lastKeyScanCode: 	4
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
Array class(Object)>>primitiveFailed:
Array class(Object)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
SortedCollection class(OrderedCollection class)>>new:
MuchasPersonas>>initialize
MuchasPersonas class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
PrimitiveFailed: primitive #basicNew: in Array class failed
23 March 2015 6:37:36.383794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

Array class(Object)>>primitiveFailed:
	Receiver: Array
	Arguments and temporary variables: 
		selector: 	#basicNew:
	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


Array class(Object)>>primitiveFailed
	Receiver: Array
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


Array class(Behavior)>>basicNew:
	Receiver: Array
	Arguments and temporary variables: 
		sizeRequested: 	[ :x :y | x abc < y abc ]
	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


Array class>>new:
	Receiver: Array
	Arguments and temporary variables: 
		sizeRequested: 	[ :x :y | x abc < y abc ]
	Receiver's instance variables: 
		superclass: 	ArrayedCollection
		methodDict: 	a MethodDictionary(#'+*'->Array>>#'+*' #asArray->Array>>#asArray #a...etc...
		format: 	6402
		layout: 	a VariableLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{WeakArray. WeakActionSequence. Cubic. MetacelloMethodSectionPath}
		name: 	#Array
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


SortedCollection class(OrderedCollection class)>>new:
	Receiver: SortedCollection
	Arguments and temporary variables: 
		anInteger: 	[ :x :y | x abc < y abc ]
	Receiver's instance variables: 
		superclass: 	OrderedCollection
		methodDict: 	a MethodDictionary(#=->SortedCollection>>#= #add:->SortedCollection...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#('sortBlock')
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SortedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	nil
		category: 	#'Collections-Sequenceable'
		traitComposition: 	{}
		localSelectors: 	nil


MuchasPersonas>>initialize
	Receiver: a MuchasPersonas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		personas: 	nil


MuchasPersonas class(Behavior)>>new
	Receiver: MuchasPersonas
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#initialize->MuchasPersonas>>#initialize )
		format: 	132
		layout: 	a FixedLayout
		instanceVariables: 	#(#personas)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MuchasPersonas
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica1Obj2
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'hola:= MuchasPersonas new'
		itsSelection: 	a Text for 'hola:= MuchasPersonas new'
		itsSelectionString: 	'hola:= MuchasPersonas new'
	Receiver's instance variables: 
		ast: 	DoIt
	^ hola := MuchasPersonas new
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 317)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 317)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (432@130)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (432@130)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 317)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(293 to: 317)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#doIt
		otherTarget: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(306446336) a PluggableTextMorph(40...etc...
		bindings: 	a Dictionary(#braian->a Persona #dario->a Persona #german->a Persona ...etc...
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#crlf
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(321126400)'Do it'
	Arguments and temporary variables: 
		evt: 	[(159@309) mouseUp 23319232 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(59.0@305.0) corner: (202.0@323.0)
		owner: 	a MenuMorph(782761984)
		submorphs: 	#()
		fullBounds: 	(59.0@305.0) corner: (202.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (344457216)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(321126400)'Do it'
	Arguments and temporary variables: 
		evt: 	[(159@309) mouseUp 23319232 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(59.0@305.0) corner: (202.0@323.0)
		owner: 	a MenuMorph(782761984)
		submorphs: 	#()
		fullBounds: 	(59.0@305.0) corner: (202.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (344457216)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(321126400)'Do it'
	Arguments and temporary variables: 
		evt: 	[(159@309) mouseUp 23319232 nil]
	Receiver's instance variables: 
		bounds: 	(59.0@305.0) corner: (202.0@323.0)
		owner: 	a MenuMorph(782761984)
		submorphs: 	#()
		fullBounds: 	(59.0@305.0) corner: (202.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (344457216)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(321126400)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
	Receiver's instance variables: 
		bounds: 	(59.0@305.0) corner: (202.0@323.0)
		owner: 	a MenuMorph(782761984)
		submorphs: 	#()
		fullBounds: 	(59.0@305.0) corner: (202.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (344457216)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MouseButtonEvent>>sentTo:
	Receiver: [(159@309) mouseUp 23319232 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(321126400)'Do it'
	Receiver's instance variables: 
		timeStamp: 	23319232
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(159@309)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(321126400)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
	Receiver's instance variables: 
		bounds: 	(59.0@305.0) corner: (202.0@323.0)
		owner: 	a MenuMorph(782761984)
		submorphs: 	#()
		fullBounds: 	(59.0@305.0) corner: (202.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (344457216)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		aMorph: 	a ToggleMenuItemMorph(321126400)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		aMorph: 	a ToggleMenuItemMorph(321126400)'Do it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(321126400)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(59.0@305.0) corner: (202.0@323.0)
		owner: 	a MenuMorph(782761984)
		submorphs: 	#()
		fullBounds: 	(59.0@305.0) corner: (202.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (344457216)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		aMorph: 	a MenuMorph(782761984)
		localEvt: 	[(159@309) mouseUp 23319232 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(321126400)'Do it'
		morphs: 	an Array(a ToggleMenuItemMorph(321126400)'Do it' a ToggleMenuItemMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		aMorph: 	a MenuMorph(782761984)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(782761984)
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(54.0@300.0) corner: (207.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(321126400)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(54.0@300.0) corner: (207.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (830210048) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(321126400)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(321126400)'Do it' a Toggl...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(782761984)
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
	Receiver's instance variables: 
		bounds: 	(54.0@300.0) corner: (207.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(321126400)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(54.0@300.0) corner: (207.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (830210048) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(321126400)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(321126400)'Do it' a Toggl...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(782761984)
	Arguments and temporary variables: 
		evt: 	[(159@309) mouseUp 23319232 nil]
	Receiver's instance variables: 
		bounds: 	(54.0@300.0) corner: (207.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(321126400)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(54.0@300.0) corner: (207.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (830210048) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(321126400)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(321126400)'Do it' a Toggl...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		focusHolder: 	a MenuMorph(782761984)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(159@309) corner: (175@325)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(159@309) corner: (175@325)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(159@309) mouseUp 23319232 nil]
		targetOffset: 	(100.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23319232 159 309 0 0 1 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(159@309) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	(0@0) corner: (1280@658)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		focusHolder: 	a MenuMorph(782761984)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(159@309) corner: (175@325)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(159@309) corner: (175@325)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(159@309) mouseOver nil nil]
		targetOffset: 	(100.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23319232 159 309 0 0 1 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
		focusHolder: 	a MenuMorph(782761984)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(159@309) corner: (175@325)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(159@309) corner: (175@325)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(159@309) mouseOver nil nil]
		targetOffset: 	(100.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23319232 159 309 0 0 1 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(159@309) mouseUp 23319232 nil]
	Receiver's instance variables: 
		bounds: 	(159@309) corner: (175@325)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(159@309) corner: (175@325)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(159@309) mouseOver nil nil]
		targetOffset: 	(100.0@4.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23319372 159 310 0 0 1 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
Array class(Object)>>primitiveFailed:
Array class(Object)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
SortedCollection class(OrderedCollection class)>>new:
MuchasPersonas>>initialize
MuchasPersonas class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Persona>><=
23 March 2015 6:39:44.086794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

Persona(Object)>>doesNotUnderstand: #'<='
	Receiver: a Persona
	Arguments and temporary variables: 
		aMessage: 	<= a Persona
		exception: 	MessageNotUnderstood: Persona>><=
		resumeValue: 	nil
	Receiver's instance variables: 
		nombre: 	'Dario'
		fecNac: 	'11/16/1993'


SortedCollection>>indexForInserting:
	Receiver: a SortedCollection(a Persona)
	Arguments and temporary variables: 
		newObject: 	a Persona
		index: 	10
		low: 	10
		high: 	10
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Persona)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection>>add:
	Receiver: a SortedCollection(a Persona)
	Arguments and temporary variables: 
		newObject: 	a Persona
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Persona)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


MuchasPersonas>>agregarPersona:
	Receiver: a MuchasPersonas
	Arguments and temporary variables: 
		unaPersona: 	a Persona
	Receiver's instance variables: 
		personas: 	a SortedCollection(a Persona)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'hola agregarPersona: dario.
hola agregarPersona: braian.'
		itsSelection: 	a Text for 'hola agregarPersona: dario.
hola agregarPersona: brai...etc...
		itsSelectionString: 	'hola agregarPersona: dario.
hola agregarPersona: braian.'
	Receiver's instance variables: 
		ast: 	DoIt
	hola agregarPersona: dario.
	^ hola agregarPersona: braian
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelectionAndDo: [ :result | result inspec...etc...
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>inspectIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#inspectIt
		otherTarget: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(306446336) a PluggableTextMorph(40...etc...
		bindings: 	a Dictionary(#braian->a Persona #dario->a Persona #german->a Persona ...etc...
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#crlf
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(139722752)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(234@359) mouseUp 23446965 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(167.0@343.0) corner: (310.0@361.0)
		owner: 	a MenuMorph(1030225920)
		submorphs: 	#()
		fullBounds: 	(167.0@343.0) corner: (310.0@361.0)
		color: 	Color black
		extension: 	a MorphExtension (163053568)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(139722752)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(234@359) mouseUp 23446965 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(167.0@343.0) corner: (310.0@361.0)
		owner: 	a MenuMorph(1030225920)
		submorphs: 	#()
		fullBounds: 	(167.0@343.0) corner: (310.0@361.0)
		color: 	Color black
		extension: 	a MorphExtension (163053568)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(139722752)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(234@359) mouseUp 23446965 nil]
	Receiver's instance variables: 
		bounds: 	(167.0@343.0) corner: (310.0@361.0)
		owner: 	a MenuMorph(1030225920)
		submorphs: 	#()
		fullBounds: 	(167.0@343.0) corner: (310.0@361.0)
		color: 	Color black
		extension: 	a MorphExtension (163053568)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(139722752)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
	Receiver's instance variables: 
		bounds: 	(167.0@343.0) corner: (310.0@361.0)
		owner: 	a MenuMorph(1030225920)
		submorphs: 	#()
		fullBounds: 	(167.0@343.0) corner: (310.0@361.0)
		color: 	Color black
		extension: 	a MorphExtension (163053568)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


MouseButtonEvent>>sentTo:
	Receiver: [(234@359) mouseUp 23446965 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(139722752)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	23446965
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(234@359)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(139722752)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
	Receiver's instance variables: 
		bounds: 	(167.0@343.0) corner: (310.0@361.0)
		owner: 	a MenuMorph(1030225920)
		submorphs: 	#()
		fullBounds: 	(167.0@343.0) corner: (310.0@361.0)
		color: 	Color black
		extension: 	a MorphExtension (163053568)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		aMorph: 	a ToggleMenuItemMorph(139722752)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		aMorph: 	a ToggleMenuItemMorph(139722752)'Inspect it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(139722752)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(167.0@343.0) corner: (310.0@361.0)
		owner: 	a MenuMorph(1030225920)
		submorphs: 	#()
		fullBounds: 	(167.0@343.0) corner: (310.0@361.0)
		color: 	Color black
		extension: 	a MorphExtension (163053568)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#inspectIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x4)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'i'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		aMorph: 	a MenuMorph(1030225920)
		localEvt: 	[(234@359) mouseUp 23446965 nil]
		index: 	3
		child: 	a ToggleMenuItemMorph(139722752)'Inspect it'
		morphs: 	an Array(a ToggleMenuItemMorph(1016856576)'Do it' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		aMorph: 	a MenuMorph(1030225920)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(1030225920)
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(162.0@300.0) corner: (315.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1016856576)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(162.0@300.0) corner: (315.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (1065615360) [other:  (basicColor -> (Color r: 0.82...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(139722752)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1016856576)'Do it' a Togg...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(1030225920)
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
	Receiver's instance variables: 
		bounds: 	(162.0@300.0) corner: (315.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1016856576)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(162.0@300.0) corner: (315.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (1065615360) [other:  (basicColor -> (Color r: 0.82...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(139722752)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1016856576)'Do it' a Togg...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(1030225920)
	Arguments and temporary variables: 
		evt: 	[(234@359) mouseUp 23446965 nil]
	Receiver's instance variables: 
		bounds: 	(162.0@300.0) corner: (315.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1016856576)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(162.0@300.0) corner: (315.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (1065615360) [other:  (basicColor -> (Color r: 0.82...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(139722752)'Inspect it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1016856576)'Do it' a Togg...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		focusHolder: 	a MenuMorph(1030225920)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(234@359) corner: (250@375)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(234@359) corner: (250@375)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(234@359) mouseUp 23446965 nil]
		targetOffset: 	(67.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23446965 234 359 0 0 1 1)
		lastKeyScanCode: 	28
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(234@359) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		focusHolder: 	a MenuMorph(1030225920)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(234@359) corner: (250@375)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(234@359) corner: (250@375)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(234@359) mouseUp 23446965 nil]
		targetOffset: 	(67.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23446965 234 359 0 0 1 1)
		lastKeyScanCode: 	28
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		focusHolder: 	a MenuMorph(1030225920)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(234@359) corner: (250@375)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(234@359) corner: (250@375)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(234@359) mouseUp 23446965 nil]
		targetOffset: 	(67.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23446965 234 359 0 0 1 1)
		lastKeyScanCode: 	28
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
	Receiver's instance variables: 
		bounds: 	(234@359) corner: (250@375)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(234@359) corner: (250@375)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(234@359) mouseUp 23446965 nil]
		targetOffset: 	(67.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23446965 234 359 0 0 1 1)
		lastKeyScanCode: 	28
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(234@359) mouseUp 23446965 nil]
		evt: 	[(234@359) mouseUp 23446965 nil]
	Receiver's instance variables: 
		bounds: 	(234@359) corner: (250@375)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(234@359) corner: (250@375)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(234@359) mouseUp 23446965 nil]
		targetOffset: 	(67.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23446965 234 359 0 0 1 1)
		lastKeyScanCode: 	28
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(234@359) mouseUp 23446965 nil]
		evtBuf: 	#(1 23446965 234 359 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(234@359) corner: (250@375)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(234@359) corner: (250@375)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(234@359) mouseUp 23446965 nil]
		targetOffset: 	(67.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23446965 234 359 0 0 1 1)
		lastKeyScanCode: 	28
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(259784704))(a DropList...etc...
		lastStepTime: 	6150238
		lastStepMessage: 	nil
		lastCycleTime: 	6150258
		alarms: 	a Heap()
		lastAlarmTime: 	6150238
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))


--- The full stack ---
Persona(Object)>>doesNotUnderstand: #'<='
SortedCollection>>indexForInserting:
SortedCollection>>add:
MuchasPersonas>>agregarPersona:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ textMorph editor evaluateSelectionAndDo: [ :result | result inspect ] ] in PluggableTextMorph>>inspectIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>inspectIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: MuchasPersonas>>add:
23 March 2015 6:41:20.203794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

MuchasPersonas(Object)>>doesNotUnderstand: #add:
	Receiver: a MuchasPersonas
	Arguments and temporary variables: 
		aMessage: 	add: a Persona
		exception: 	MessageNotUnderstood: MuchasPersonas>>add:
		resumeValue: 	nil
	Receiver's instance variables: 
		personas: 	a SortedCollection(a Persona)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'hola add: dario.
hola add: braian.'
		itsSelection: 	a Text for 'hola add: dario.
hola add: braian.'
		itsSelectionString: 	'hola add: dario.
hola add: braian.'
	Receiver's instance variables: 
		ast: 	DoIt
	hola add: dario.
	^ hola add: braian
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#doIt
		otherTarget: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(306446336) a PluggableTextMorph(40...etc...
		bindings: 	a Dictionary(#braian->a Persona #dario->a Persona #german->a Persona ...etc...
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#crlf
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(819724288)'Do it'
	Arguments and temporary variables: 
		evt: 	[(103@318) mouseUp 23543046 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(69.0@305.0) corner: (212.0@323.0)
		owner: 	a MenuMorph(421789696)
		submorphs: 	#()
		fullBounds: 	(69.0@305.0) corner: (212.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (843055104)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(819724288)'Do it'
	Arguments and temporary variables: 
		evt: 	[(103@318) mouseUp 23543046 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(69.0@305.0) corner: (212.0@323.0)
		owner: 	a MenuMorph(421789696)
		submorphs: 	#()
		fullBounds: 	(69.0@305.0) corner: (212.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (843055104)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(819724288)'Do it'
	Arguments and temporary variables: 
		evt: 	[(103@318) mouseUp 23543046 nil]
	Receiver's instance variables: 
		bounds: 	(69.0@305.0) corner: (212.0@323.0)
		owner: 	a MenuMorph(421789696)
		submorphs: 	#()
		fullBounds: 	(69.0@305.0) corner: (212.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (843055104)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(819724288)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
	Receiver's instance variables: 
		bounds: 	(69.0@305.0) corner: (212.0@323.0)
		owner: 	a MenuMorph(421789696)
		submorphs: 	#()
		fullBounds: 	(69.0@305.0) corner: (212.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (843055104)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MouseButtonEvent>>sentTo:
	Receiver: [(103@318) mouseUp 23543046 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(819724288)'Do it'
	Receiver's instance variables: 
		timeStamp: 	23543046
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(103@318)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(819724288)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
	Receiver's instance variables: 
		bounds: 	(69.0@305.0) corner: (212.0@323.0)
		owner: 	a MenuMorph(421789696)
		submorphs: 	#()
		fullBounds: 	(69.0@305.0) corner: (212.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (843055104)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		aMorph: 	a ToggleMenuItemMorph(819724288)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		aMorph: 	a ToggleMenuItemMorph(819724288)'Do it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(819724288)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(69.0@305.0) corner: (212.0@323.0)
		owner: 	a MenuMorph(421789696)
		submorphs: 	#()
		fullBounds: 	(69.0@305.0) corner: (212.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (843055104)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		aMorph: 	a MenuMorph(421789696)
		localEvt: 	[(103@318) mouseUp 23543046 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(819724288)'Do it'
		morphs: 	an Array(a ToggleMenuItemMorph(819724288)'Do it' a ToggleMenuItemMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		aMorph: 	a MenuMorph(421789696)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(421789696)
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(64.0@300.0) corner: (217.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(819724288)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(64.0@300.0) corner: (217.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (469237760) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(819724288)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(819724288)'Do it' a Toggl...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(421789696)
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
	Receiver's instance variables: 
		bounds: 	(64.0@300.0) corner: (217.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(819724288)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(64.0@300.0) corner: (217.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (469237760) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(819724288)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(819724288)'Do it' a Toggl...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(421789696)
	Arguments and temporary variables: 
		evt: 	[(103@318) mouseUp 23543046 nil]
	Receiver's instance variables: 
		bounds: 	(64.0@300.0) corner: (217.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(819724288)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(64.0@300.0) corner: (217.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (469237760) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(819724288)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(819724288)'Do it' a Toggl...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		focusHolder: 	a MenuMorph(421789696)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(101@314) corner: (117@330)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@314) corner: (117@330)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@314) mouseOver nil nil]
		targetOffset: 	(34.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23543093 103 317 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(103@318) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	(0@0) corner: (1280@658)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		focusHolder: 	a MenuMorph(421789696)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(101@314) corner: (117@330)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@314) corner: (117@330)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@314) mouseOver nil nil]
		targetOffset: 	(34.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23543093 103 317 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		focusHolder: 	a MenuMorph(421789696)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(101@314) corner: (117@330)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@314) corner: (117@330)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@314) mouseOver nil nil]
		targetOffset: 	(34.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23543093 103 317 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
	Receiver's instance variables: 
		bounds: 	(101@314) corner: (117@330)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@314) corner: (117@330)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@314) mouseOver nil nil]
		targetOffset: 	(34.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23543093 103 317 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@318) mouseUp 23543046 nil]
		evt: 	[(103@318) mouseUp 23543046 nil]
	Receiver's instance variables: 
		bounds: 	(101@314) corner: (117@330)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@314) corner: (117@330)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@314) mouseOver nil nil]
		targetOffset: 	(34.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23543093 103 317 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(103@318) mouseUp 23543046 nil]
		evtBuf: 	#(1 23543046 103 318 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(101@314) corner: (117@330)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(101@314) corner: (117@330)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(101@314) mouseOver nil nil]
		targetOffset: 	(34.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23543093 103 317 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	6246477
		lastStepMessage: 	nil
		lastCycleTime: 	6246477
		alarms: 	a Heap()
		lastAlarmTime: 	6246477
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	6246477
		lastStepMessage: 	nil
		lastCycleTime: 	6246477
		alarms: 	a Heap()
		lastAlarmTime: 	6246477
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	6246477
		lastStepMessage: 	nil
		lastCycleTime: 	6246477
		alarms: 	a Heap()
		lastAlarmTime: 	6246477
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
MuchasPersonas(Object)>>doesNotUnderstand: #add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Persona>><=
23 March 2015 6:41:37.085794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

Persona(Object)>>doesNotUnderstand: #'<='
	Receiver: a Persona
	Arguments and temporary variables: 
		aMessage: 	<= a Persona
		exception: 	MessageNotUnderstood: Persona>><=
		resumeValue: 	nil
	Receiver's instance variables: 
		nombre: 	'Dario'
		fecNac: 	'11/16/1993'


SortedCollection>>indexForInserting:
	Receiver: a SortedCollection(a Persona)
	Arguments and temporary variables: 
		newObject: 	a Persona
		index: 	10
		low: 	10
		high: 	10
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Persona)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection>>add:
	Receiver: a SortedCollection(a Persona)
	Arguments and temporary variables: 
		newObject: 	a Persona
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Persona)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'hola add: dario.
hola add: braian.'
		itsSelection: 	a Text for 'hola add: dario.
hola add: braian.'
		itsSelectionString: 	'hola add: dario.
hola add: braian.'
	Receiver's instance variables: 
		ast: 	DoIt
	hola add: dario.
	^ hola add: braian
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(322 to: 355)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#doIt
		otherTarget: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(306446336) a PluggableTextMorph(40...etc...
		bindings: 	a Dictionary(#braian->a Persona #dario->a Persona #german->a Persona ...etc...
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#crlf
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(849870848)'Do it'
	Arguments and temporary variables: 
		evt: 	[(103@316) mouseUp 23559941 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(68.0@305.0) corner: (211.0@323.0)
		owner: 	a MenuMorph(62652416)
		submorphs: 	#()
		fullBounds: 	(68.0@305.0) corner: (211.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (873201664)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(849870848)'Do it'
	Arguments and temporary variables: 
		evt: 	[(103@316) mouseUp 23559941 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(68.0@305.0) corner: (211.0@323.0)
		owner: 	a MenuMorph(62652416)
		submorphs: 	#()
		fullBounds: 	(68.0@305.0) corner: (211.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (873201664)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(849870848)'Do it'
	Arguments and temporary variables: 
		evt: 	[(103@316) mouseUp 23559941 nil]
	Receiver's instance variables: 
		bounds: 	(68.0@305.0) corner: (211.0@323.0)
		owner: 	a MenuMorph(62652416)
		submorphs: 	#()
		fullBounds: 	(68.0@305.0) corner: (211.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (873201664)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(849870848)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
	Receiver's instance variables: 
		bounds: 	(68.0@305.0) corner: (211.0@323.0)
		owner: 	a MenuMorph(62652416)
		submorphs: 	#()
		fullBounds: 	(68.0@305.0) corner: (211.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (873201664)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MouseButtonEvent>>sentTo:
	Receiver: [(103@316) mouseUp 23559941 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(849870848)'Do it'
	Receiver's instance variables: 
		timeStamp: 	23559941
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(103@316)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(849870848)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
	Receiver's instance variables: 
		bounds: 	(68.0@305.0) corner: (211.0@323.0)
		owner: 	a MenuMorph(62652416)
		submorphs: 	#()
		fullBounds: 	(68.0@305.0) corner: (211.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (873201664)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		aMorph: 	a ToggleMenuItemMorph(849870848)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		aMorph: 	a ToggleMenuItemMorph(849870848)'Do it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(849870848)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(68.0@305.0) corner: (211.0@323.0)
		owner: 	a MenuMorph(62652416)
		submorphs: 	#()
		fullBounds: 	(68.0@305.0) corner: (211.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (873201664)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		aMorph: 	a MenuMorph(62652416)
		localEvt: 	[(103@316) mouseUp 23559941 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(849870848)'Do it'
		morphs: 	an Array(a ToggleMenuItemMorph(849870848)'Do it' a ToggleMenuItemMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		aMorph: 	a MenuMorph(62652416)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(62652416)
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(63.0@300.0) corner: (216.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(849870848)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(63.0@300.0) corner: (216.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (104071168) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(849870848)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(849870848)'Do it' a Toggl...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(62652416)
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
	Receiver's instance variables: 
		bounds: 	(63.0@300.0) corner: (216.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(849870848)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(63.0@300.0) corner: (216.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (104071168) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(849870848)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(849870848)'Do it' a Toggl...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(62652416)
	Arguments and temporary variables: 
		evt: 	[(103@316) mouseUp 23559941 nil]
	Receiver's instance variables: 
		bounds: 	(63.0@300.0) corner: (216.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(849870848)'Do it' a ToggleMenuItemMor...etc...
		fullBounds: 	(63.0@300.0) corner: (216.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (104071168) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(849870848)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(849870848)'Do it' a Toggl...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		focusHolder: 	a MenuMorph(62652416)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(103@316) corner: (119@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(103@316) corner: (119@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(103@316) mouseUp 23559941 nil]
		targetOffset: 	(35.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23559941 103 316 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(103@316) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		focusHolder: 	a MenuMorph(62652416)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(103@316) corner: (119@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(103@316) corner: (119@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(103@316) mouseUp 23559941 nil]
		targetOffset: 	(35.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23559941 103 316 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		focusHolder: 	a MenuMorph(62652416)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(103@316) corner: (119@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(103@316) corner: (119@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(103@316) mouseUp 23559941 nil]
		targetOffset: 	(35.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23559941 103 316 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
	Receiver's instance variables: 
		bounds: 	(103@316) corner: (119@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(103@316) corner: (119@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(103@316) mouseUp 23559941 nil]
		targetOffset: 	(35.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23559941 103 316 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(103@316) mouseUp 23559941 nil]
		evt: 	[(103@316) mouseUp 23559941 nil]
	Receiver's instance variables: 
		bounds: 	(103@316) corner: (119@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(103@316) corner: (119@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(103@316) mouseUp 23559941 nil]
		targetOffset: 	(35.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23559941 103 316 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(103@316) mouseUp 23559941 nil]
		evtBuf: 	#(1 23559941 103 316 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(103@316) corner: (119@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(103@316) corner: (119@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(103@316) mouseUp 23559941 nil]
		targetOffset: 	(35.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23559941 103 316 0 0 1 1)
		lastKeyScanCode: 	68
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(172752896))(a SearchMorp...etc...
		lastStepTime: 	6263232
		lastStepMessage: 	nil
		lastCycleTime: 	6263252
		alarms: 	a Heap()
		lastAlarmTime: 	6263232
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(760479744))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(760479744))


--- The full stack ---
Persona(Object)>>doesNotUnderstand: #'<='
SortedCollection>>indexForInserting:
SortedCollection>>add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: Persona>><=
23 March 2015 6:43:02.741794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

Persona(Object)>>doesNotUnderstand: #'<='
	Receiver: a Persona
	Arguments and temporary variables: 
		aMessage: 	<= a Persona
		exception: 	MessageNotUnderstood: Persona>><=
		resumeValue: 	nil
	Receiver's instance variables: 
		nombre: 	'Dario'
		fecNac: 	'11/16/1993'


SortedCollection>>indexForInserting:
	Receiver: a SortedCollection(a Persona)
	Arguments and temporary variables: 
		newObject: 	a Persona
		index: 	10
		low: 	10
		high: 	10
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Persona)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection>>add:
	Receiver: a SortedCollection(a Persona)
	Arguments and temporary variables: 
		newObject: 	a Persona
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Persona)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


MuchasPersonas>>agregarPersona:
	Receiver: a MuchasPersonas
	Arguments and temporary variables: 
		unaPersona: 	a Persona
	Receiver's instance variables: 
		personas: 	a SortedCollection(a Persona)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'hola agregarPersona: dario.
hola agregarPersona: braian.'
		itsSelection: 	a Text for 'hola agregarPersona: dario.
hola agregarPersona: brai...etc...
		itsSelectionString: 	'hola agregarPersona: dario.
hola agregarPersona: braian.'
	Receiver's instance variables: 
		ast: 	DoIt
	hola agregarPersona: dario.
	^ hola agregarPersona: braian
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


SmalltalkEditor>>evaluateSelection
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph editor evaluateSelection ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ result := editBlock value ]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@162)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@162)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>handleEdit:
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		result: 	nil
		editBlock: 	[ textMorph editor evaluateSelection ]
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


PluggableTextMorph>>doIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(320 to: 375)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


Workspace(Object)>>perform:orSendTo:
	Receiver: a Workspace
	Arguments and temporary variables: 
		selector: 	#doIt
		otherTarget: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(306446336) a PluggableTextMorph(40...etc...
		bindings: 	a Dictionary(#braian->a Persona #dario->a Persona #german->a Persona ...etc...
		acceptDroppedMorphs: 	false
		acceptAction: 	nil
		mustDeclareVariables: 	false
		fileName: 	nil
		lineEnding: 	#crlf
		encoding: 	'utf-8'
		stylingActive: 	true
		contents: 	a Text for '((''16/11/1993'') asDate) year - (Date today) year'


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(1058537472)'Do it'
	Arguments and temporary variables: 
		evt: 	[(127@316) mouseUp 23645617 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(73.0@305.0) corner: (216.0@323.0)
		owner: 	a MenuMorph(798228480)
		submorphs: 	#()
		fullBounds: 	(73.0@305.0) corner: (216.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (8126464)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(1058537472)'Do it'
	Arguments and temporary variables: 
		evt: 	[(127@316) mouseUp 23645617 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(73.0@305.0) corner: (216.0@323.0)
		owner: 	a MenuMorph(798228480)
		submorphs: 	#()
		fullBounds: 	(73.0@305.0) corner: (216.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (8126464)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(1058537472)'Do it'
	Arguments and temporary variables: 
		evt: 	[(127@316) mouseUp 23645617 nil]
	Receiver's instance variables: 
		bounds: 	(73.0@305.0) corner: (216.0@323.0)
		owner: 	a MenuMorph(798228480)
		submorphs: 	#()
		fullBounds: 	(73.0@305.0) corner: (216.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (8126464)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(1058537472)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
	Receiver's instance variables: 
		bounds: 	(73.0@305.0) corner: (216.0@323.0)
		owner: 	a MenuMorph(798228480)
		submorphs: 	#()
		fullBounds: 	(73.0@305.0) corner: (216.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (8126464)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MouseButtonEvent>>sentTo:
	Receiver: [(127@316) mouseUp 23645617 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(1058537472)'Do it'
	Receiver's instance variables: 
		timeStamp: 	23645617
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(127@316)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(1058537472)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
	Receiver's instance variables: 
		bounds: 	(73.0@305.0) corner: (216.0@323.0)
		owner: 	a MenuMorph(798228480)
		submorphs: 	#()
		fullBounds: 	(73.0@305.0) corner: (216.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (8126464)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		aMorph: 	a ToggleMenuItemMorph(1058537472)'Do it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		aMorph: 	a ToggleMenuItemMorph(1058537472)'Do it'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(1058537472)'Do it'
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(73.0@305.0) corner: (216.0@323.0)
		owner: 	a MenuMorph(798228480)
		submorphs: 	#()
		fullBounds: 	(73.0@305.0) corner: (216.0@323.0)
		color: 	Color black
		extension: 	a MorphExtension (8126464)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Do it'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a Workspace
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#doIt a PluggableTextMorph(408420352))
		icon: 	ColorForm(16x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'd'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		aMorph: 	a MenuMorph(798228480)
		localEvt: 	[(127@316) mouseUp 23645617 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(1058537472)'Do it'
		morphs: 	an Array(a ToggleMenuItemMorph(1058537472)'Do it' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		aMorph: 	a MenuMorph(798228480)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(798228480)
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(68.0@300.0) corner: (221.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1058537472)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(68.0@300.0) corner: (221.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (845676544) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(1058537472)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1058537472)'Do it' a Togg...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(798228480)
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
	Receiver's instance variables: 
		bounds: 	(68.0@300.0) corner: (221.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1058537472)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(68.0@300.0) corner: (221.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (845676544) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(1058537472)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1058537472)'Do it' a Togg...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(798228480)
	Arguments and temporary variables: 
		evt: 	[(127@316) mouseUp 23645617 nil]
	Receiver's instance variables: 
		bounds: 	(68.0@300.0) corner: (221.0@640.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(1058537472)'Do it' a ToggleMenuItemMo...etc...
		fullBounds: 	(68.0@300.0) corner: (221.0@640.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (845676544) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a Workspace
		selectedItem: 	a ToggleMenuItemMorph(1058537472)'Do it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(1058537472)'Do it' a Togg...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		focusHolder: 	a MenuMorph(798228480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(127@316) corner: (143@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(127@316) corner: (143@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(127@316) mouseUp 23645617 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23645617 127 316 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(127@316) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		focusHolder: 	a MenuMorph(798228480)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(127@316) corner: (143@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(127@316) corner: (143@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(127@316) mouseUp 23645617 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23645617 127 316 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		focusHolder: 	a MenuMorph(798228480)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(127@316) corner: (143@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(127@316) corner: (143@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(127@316) mouseUp 23645617 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23645617 127 316 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
	Receiver's instance variables: 
		bounds: 	(127@316) corner: (143@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(127@316) corner: (143@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(127@316) mouseUp 23645617 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23645617 127 316 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(127@316) mouseUp 23645617 nil]
		evt: 	[(127@316) mouseUp 23645617 nil]
	Receiver's instance variables: 
		bounds: 	(127@316) corner: (143@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(127@316) corner: (143@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(127@316) mouseUp 23645617 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23645617 127 316 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		evt: 	[(127@316) mouseUp 23645617 nil]
		evtBuf: 	#(1 23645617 127 316 0 0 1 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(127@316) corner: (143@332)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(127@316) corner: (143@332)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(127@316) mouseUp 23645617 nil]
		targetOffset: 	(53.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 23645617 127 316 0 0 1 1)
		lastKeyScanCode: 	90
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(511705088) [world]
		h: 	a HandMorph(760479744)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(760479744))
		viewBox: 	(0@0) corner: (1280@658)
		canvas: 	a FormCanvas on: DisplayScreen(1280x658x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(259784704))(a DropList...etc...
		lastStepTime: 	6348900
		lastStepMessage: 	nil
		lastCycleTime: 	6348920
		alarms: 	a Heap()
		lastAlarmTime: 	6348900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 



--- The full stack ---
Persona(Object)>>doesNotUnderstand: #'<='
SortedCollection>>indexForInserting:
SortedCollection>>add:
MuchasPersonas>>agregarPersona:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
SmalltalkEditor>>evaluateSelection
[ textMorph editor evaluateSelection ] in PluggableTextMorph>>doIt
[ result := editBlock value ] in PluggableTextMorph>>handleEdit:
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>handleEdit:
PluggableTextMorph>>doIt
Workspace(Object)>>perform:orSendTo:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
PluggableTextMorph>>yellowButtonActivity:
SmalltalkEditor(TextEditor)>>mouseUp:
[ editor mouseUp: evt ] in TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView(TextMorph)>>handleInteraction:
TextMorphForEditView>>handleInteraction:
TextMorphForEditView(TextMorph)>>mouseUp:
TextMorphForEditView>>mouseUp:
TextMorphForEditView(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:55:36.839794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'conNombre:'
		defTokens: 	an OrderedCollection('conNombre:' 'unNombre' '^self' 'new' 'iniciali...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: unNombre'...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(60 to: 59)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24399679
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(156@51)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:55:47.017794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'onNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'onNombre:'
		defTokens: 	an OrderedCollection('onNombre:' 'unNombre' '^self' 'new' 'inicializ...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'onNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'onNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'onNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'onNombre: unNombre

	^self new inicializarNombre: unN...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'onNombre: unNombre

	^self new inicializarNombre: unN...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->onNombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->onNombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->onNombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24409897
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(115@61)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->onNombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->onNombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:55:52.351794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'ConNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'ConNombre:'
		defTokens: 	an OrderedCollection('ConNombre:' 'unNombre' '^self' 'new' 'iniciali...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'ConNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'ConNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'ConNombre: unNombre

	^self new inicializarNombre: unNombre'...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'ConNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'ConNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(2 to: 1)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->ConNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->ConNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->ConNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24415217
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(179@47)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->ConNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->ConNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:56:18.564794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'conombre:'
		defTokens: 	an OrderedCollection('conombre:' 'unNombre' '^self' 'new' 'inicializ...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'conombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'conombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conombre: unNombre

	^self new inicializarNombre: unN...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(4 to: 3)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conombre: unNombre

	^self new inicializarNombre: unN...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(4 to: 3)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(4 to: 3)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(4 to: 3)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(4 to: 3)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(4 to: 3)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24441425
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(108@37)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conombre: unNombre

	^self...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:56:38.701794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'asdasd: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'asdasd:'
		defTokens: 	an OrderedCollection('asdasd:' 'unNombre' '^self' 'new' 'inicializar...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'asdasd: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'asdasd: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'asdasd: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'asdasd: unNombre

	^self new inicializarNombre: unNom...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(7 to: 6)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'asdasd: unNombre

	^self new inicializarNombre: unNom...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(7 to: 6)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(7 to: 6)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(7 to: 6)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(7 to: 6)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(7 to: 6)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->asdasd: unNombre

	^self n...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->asdasd: unNombre

	^self n...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->asdasd: unNombre

	^self n...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24461596
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(236@44)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->asdasd: unNombre

	^self n...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->asdasd: unNombre

	^self n...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:57:05.038794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	' inicializarNombre: unNombre

	^self new inicializarNombre: unNombre'...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'inicializarNombre:'
		defTokens: 	an OrderedCollection('inicializarNombre:' 'unNombre' '^self' 'new' '...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	' inicializarNombre: unNombre

	^self new inicializarNombre: unNombre'...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	' inicializarNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ' inicializarNombre: unNombre

	^self new inicializarNombre: ...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ' inicializarNombre: unNombre

	^self new inicializarN...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ' inicializarNombre: unNombre

	^self new inicializarN...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(2 to: 1)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(2 to: 1)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '  Variable or expression expected ->inicializarNombre: unNomb...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '  Variable or expression expected ->inicializarNombre: unNomb...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '  Variable or expression expected ->inicializarNombre: unNomb...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24487898
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(184@59)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '  Variable or expression expected ->inicializarNombre: unNomb...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for '  Variable or expression expected ->inicializarNombre: unNomb...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:57:11.119794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'inicializarNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'inicializarNombre:'
		defTokens: 	an OrderedCollection('inicializarNombre:' 'unNombre' '^self' 'new' '...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'inicializarNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'inicializarNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'inicializarNombre: unNombre

	^self new inicializarNombre: u...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'inicializarNombre: unNombre

	^self new inicializarNo...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'inicializarNombre: unNombre

	^self new inicializarNo...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(1 to: 0)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(1 to: 0)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->inicializarNombre: unNombr...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->inicializarNombre: unNombr...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->inicializarNombre: unNombr...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24494013
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(152@ -4)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->inicializarNombre: unNombr...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->inicializarNombre: unNombr...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:58:01.712794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	Equipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'conNombre:'
		defTokens: 	an OrderedCollection('conNombre:' 'unNombre' '^self' 'new' 'iniciali...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: unNombre'...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	Equipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(Equipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(21 to: 20)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(21 to: 20)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(21 to: 20)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(21 to: 20)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(21 to: 20)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(21 to: 20)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24544588
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(121@48)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:59:11.041794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	EKipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'conNombre:'
		defTokens: 	an OrderedCollection('conNombre:' 'unNombre' '^self' 'new' 'iniciali...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'conNombre: unNombre

	^self new inicializarNombre: unNombre'
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: unNombre'...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'conNombre: unNombre

	^self new inicializarNombre: un...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(60 to: 59)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	nil
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#accept on Ctrl + S do [ :morph | morph acceptContents ]
)
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	3
		each: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil #accept on Ctrl + S do [ :morph | morph acceptContents ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#TextMorph
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategoryTarge...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorph) aKMCategor...etc...
		firstIndex: 	1
		lastIndex: 	3


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a TextMorphForEditView(881065984)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-s>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(881065984)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-s>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		timeStamp: 	24613915
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-8@ -1)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	19
		charCode: 	19
		scanCode: 	83


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@50)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@50)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^sel...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "generateWithSource" is nil
23 March 2015 6:59:58.358794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	generateWithSource
		exception: 	MessageNotUnderstood: receiver of "generateWithSource" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	nil
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	' Variable or expression expected ->conNombre: unNombre

	^self new in...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	EKipo class
		oldClass: 	Object class
		class: 	nil
		newClassName: 	'Variable'
		defTokens: 	an OrderedCollection('Variable' 'or' 'expression' 'expected' '->conN...etc...
		keywdIx: 	0
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	' Variable or expression expected ->conNombre: unNombre

	^self new in...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	' Variable or expression expected ->conNombre: unNombre

	^self new inic...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for ' Variable or expression expected ->conNombre: unNombre

	^se...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ' Variable or expression expected ->conNombre: unNombr...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for ' Variable or expression expected ->conNombre: unNombr...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(60 to: 59)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		choice: 	true
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		aSymbol: 	#wantToChange
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(60 to: 59)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>removeClasses
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		result: 	nil
		scroll: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	EKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(EKipo->true )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{EKipo. Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ target removeClasses ] in AbstractNautilusUI class>>classesMenu:
	Receiver: AbstractNautilusUI
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		superclass: 	AbstractTool
		methodDict: 	a MethodDictionary(size 430)
		format: 	180
		layout: 	a FixedLayout
		instanceVariables: 	#(#model #window #hierarchyClass #cachedHierarchy #sourceTex...etc...
		organization: 	a ClassOrganization
		subclasses: 	{NautilusUI}
		name: 	#AbstractNautilusUI
		classPool: 	a Dictionary(#ClassesIconsCache->a WeakIdentityKeyDictionary(EKipo->...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Nautilus
		traitComposition: 	{}
		localSelectors: 	nil


BlockClosure>>cull:
	Receiver: [ target removeClasses ]
	Arguments and temporary variables: 
		anArg: 	a PackageTreeNautilusUI
	Receiver's instance variables: 
		outerContext: 	AbstractNautilusUI class>>classesMenu:
		startpc: 	704
		numArgs: 	0


[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(215482368)'Remove...'
	Arguments and temporary variables: 
		evt: 	[(796@330) mouseUp 24660076 nil]
		w: 	a WorldMorph(511705088) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(766.0@323.0) corner: (948.0@341.0)
		owner: 	a MenuMorph(170917888)
		submorphs: 	#()
		fullBounds: 	(766.0@323.0) corner: (948.0@341.0)
		color: 	Color black
		extension: 	a MorphExtension (244842496)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeClasses ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, c'


BlockClosure>>ensure:
	Receiver: [ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selec...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	134
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(s...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(215482368)'Remove...'
	Arguments and temporary variables: 
		evt: 	[(796@330) mouseUp 24660076 nil]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(766.0@323.0) corner: (948.0@341.0)
		owner: 	a MenuMorph(170917888)
		submorphs: 	#()
		fullBounds: 	(766.0@323.0) corner: (948.0@341.0)
		color: 	Color black
		extension: 	a MorphExtension (244842496)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeClasses ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, c'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(215482368)'Remove...'
	Arguments and temporary variables: 
		evt: 	[(796@330) mouseUp 24660076 nil]
	Receiver's instance variables: 
		bounds: 	(766.0@323.0) corner: (948.0@341.0)
		owner: 	a MenuMorph(170917888)
		submorphs: 	#()
		fullBounds: 	(766.0@323.0) corner: (948.0@341.0)
		color: 	Color black
		extension: 	a MorphExtension (244842496)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeClasses ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, c'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(215482368)'Remove...'
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
	Receiver's instance variables: 
		bounds: 	(766.0@323.0) corner: (948.0@341.0)
		owner: 	a MenuMorph(170917888)
		submorphs: 	#()
		fullBounds: 	(766.0@323.0) corner: (948.0@341.0)
		color: 	Color black
		extension: 	a MorphExtension (244842496)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeClasses ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, c'


MouseButtonEvent>>sentTo:
	Receiver: [(796@330) mouseUp 24660076 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(215482368)'Remove...'
	Receiver's instance variables: 
		timeStamp: 	24660076
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(796@330)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(215482368)'Remove...'
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
	Receiver's instance variables: 
		bounds: 	(766.0@323.0) corner: (948.0@341.0)
		owner: 	a MenuMorph(170917888)
		submorphs: 	#()
		fullBounds: 	(766.0@323.0) corner: (948.0@341.0)
		color: 	Color black
		extension: 	a MorphExtension (244842496)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeClasses ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, c'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		aMorph: 	a ToggleMenuItemMorph(215482368)'Remove...'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		aMorph: 	a ToggleMenuItemMorph(215482368)'Remove...'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(215482368)'Remove...'
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(766.0@323.0) corner: (948.0@341.0)
		owner: 	a MenuMorph(170917888)
		submorphs: 	#()
		fullBounds: 	(766.0@323.0) corner: (948.0@341.0)
		color: 	Color black
		extension: 	a MorphExtension (244842496)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Remove...'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ target removeClasses ]
		selector: 	#cull:
		arguments: 	an Array(a PackageTreeNautilusUI)
		icon: 	ColorForm(14x16x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'x, c'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		aMorph: 	a MenuMorph(170917888)
		localEvt: 	[(796@330) mouseUp 24660076 nil]
		index: 	22
		child: 	a ToggleMenuItemMorph(215482368)'Remove...'
		morphs: 	an Array(a ToggleMenuItemMorph(257163264)'Refactoring' a ToggleMenuItem...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		aMorph: 	a MenuMorph(170917888)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(170917888)
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(761.0@63.0) corner: (953.0@382.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(257163264)'Refactoring' a ToggleMenuI...etc...
		fullBounds: 	(761.0@63.0) corner: (953.0@382.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (194248704) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a PackageTreeNautilusUI
		selectedItem: 	a ToggleMenuItemMorph(215482368)'Remove...'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(257163264)'Refactoring' a...etc...


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(170917888)
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
	Receiver's instance variables: 
		bounds: 	(761.0@63.0) corner: (953.0@382.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(257163264)'Refactoring' a ToggleMenuI...etc...
		fullBounds: 	(761.0@63.0) corner: (953.0@382.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (194248704) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a PackageTreeNautilusUI
		selectedItem: 	a ToggleMenuItemMorph(215482368)'Remove...'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(257163264)'Refactoring' a...etc...


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(170917888)
	Arguments and temporary variables: 
		evt: 	[(796@330) mouseUp 24660076 nil]
	Receiver's instance variables: 
		bounds: 	(761.0@63.0) corner: (953.0@382.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(257163264)'Refactoring' a ToggleMenuI...etc...
		fullBounds: 	(761.0@63.0) corner: (953.0@382.0)
		color: 	(Color r: 0.894 g: 0.894 b: 0.894 alpha: 1.0)
		extension: 	a MorphExtension (194248704) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a PackageTreeNautilusUI
		selectedItem: 	a ToggleMenuItemMorph(215482368)'Remove...'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		activatorDockingBar: 	nil
		embeddable: 	nil
		menuItems: 	an OrderedCollection(a ToggleMenuItemMorph(257163264)'Refactoring' a...etc...


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		focusHolder: 	a MenuMorph(170917888)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(763@384) corner: (779@400)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(763@384) corner: (779@400)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(763@384) mouseOver nil nil]
		targetOffset: 	(27.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 24661308 763 384 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	[(796@330) mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a NautilusWindow(745275392) a Sys...etc...
		fullBounds: 	(0@0) corner: (1280@658)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		focusHolder: 	a MenuMorph(170917888)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(763@384) corner: (779@400)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(763@384) corner: (779@400)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(763@384) mouseOver nil nil]
		targetOffset: 	(27.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 24661308 763 384 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[(796@330) mouseUp 24660076 nil]
		focusHolder: 	a MenuMorph(170917888)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(763@384) corner: (779@400)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	(763@384) corner: (779@400)
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(763@384) mouseOver nil nil]
		targetOffset: 	(27.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 24661308 763 384 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #generateWithSource
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
PluggableTextMorphWithLimits(PluggableTextMorph)>>promptForCancel
PluggableTextMorphWithLimits(PluggableTextMorph)>>update:
PackageTreeNautilusUI(AbstractNautilusUI)>>okToChange
PackageTreeNautilusUI(AbstractNautilusUI)>>removeClasses
[ target removeClasses ] in AbstractNautilusUI class>>classesMenu:
BlockClosure>>cull:
[ 
| selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ 
		selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "asNautilusSelection" is nil
23 March 2015 7:00:12.566794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

UndefinedObject(Object)>>doesNotUnderstand: #asNautilusSelection
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	asNautilusSelection
		exception: 	MessageNotUnderstood: receiver of "asNautilusSelection" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PackageTreeNautilus class>>parentOfClass:
	Receiver: PackageTreeNautilus
	Arguments and temporary variables: 
		aClass: 	AnObsoleteEKipo class
		package: 	a RPackage(_UnpackagedPackage)
		tag: 	nil
	Receiver's instance variables: 
		superclass: 	Nautilus
		methodDict: 	a MethodDictionary(#defaultUIClass->PackageTreeNautilus>>#defaultUI...etc...
		format: 	164
		layout: 	a FixedLayout
		instanceVariables: 	#()
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PackageTreeNautilus
		classPool: 	a Dictionary(#ShowGroupsOnTop->true )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Nautilus-Tree'
		traitComposition: 	{}
		localSelectors: 	nil
		populateMethodList: 	nil
		emptyCommentWarning: 	nil
		groups: 	a GroupHolder
		maxSize: 	10
		useOldStyleKeys: 	nil


PackageTreeNautilus(Nautilus)>>parentOfClass:
	Receiver: a PackageTreeNautilus
	Arguments and temporary variables: 
		aClass: 	AnObsoleteEKipo class
	Receiver's instance variables: 
		announcer: 	a NautilusAnnouncer
		browsedEnvironment: 	Smalltalk
		browsingHistory: 	a NavigationHistory
		plugins: 	an OrderedCollection()
		selectedCategory: 	nil
		selectedClass: 	nil
		selectedGroup: 	nil
		selectedMethod: 	nil
		selectedPackage: 	a PackageTreePackageSelection
		showCategories: 	true
		showComment: 	false
		showGroups: 	false
		showHierarchy: 	true
		showInstance: 	false
		showPackages: 	true
		ui: 	a PackageTreeNautilusUI
		uiClass: 	nil


PackageTreeNautilusUI(NautilusUI)>>parentOfClass:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	AnObsoleteEKipo class
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	AnObsoleteEKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary()
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(NautilusUI)>>selectedClassWithoutChangingSelection:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	AnObsoleteEKipo class
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	AnObsoleteEKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary()
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>selectedClass:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aClass: 	AnObsoleteEKipo class
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	AnObsoleteEKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary()
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI>>updateBothView
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		selectedPackage: 	a PackageTreePackageSelection
		selectedClass: 	AnObsoleteEKipo class
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	AnObsoleteEKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary()
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>classRemoved:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		anAnnouncement: 	a ClassRemoved
		class: 	AnObsoleteEKipo
		oldPackage: 	a RPackage(Practica1Obj2)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	AnObsoleteEKipo
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary()
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. Mascota. MuchasPersonas. Persona. Respuestas}
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


WeakMessageSend>>value:
	Receiver: WeakMessageSend(#classRemoved: -> a PackageTreeNautilusUI)
	Arguments and temporary variables: 
		anObject: 	a ClassRemoved
	Receiver's instance variables: 
		selector: 	#classRemoved:
		shouldBeNil: 	#()
		arguments: 	a WeakArray()


WeakMessageSend>>cull:
	Receiver: WeakMessageSend(#classRemoved: -> a PackageTreeNautilusUI)
	Arguments and temporary variables: 
		arg: 	a ClassRemoved
	Receiver's instance variables: 
		selector: 	#classRemoved:
		shouldBeNil: 	#()
		arguments: 	a WeakArray()


WeakMessageSend>>cull:cull:
	Receiver: WeakMessageSend(#classRemoved: -> a PackageTreeNautilusUI)
	Arguments and temporary variables: 
		arg1: 	a ClassRemoved
		arg2: 	a SystemAnnouncer
	Receiver's instance variables: 
		selector: 	#classRemoved:
		shouldBeNil: 	#()
		arguments: 	a WeakArray()


[ action cull: anAnnouncement cull: announcer ] in WeakAnnouncementSubscription>>deliver:
	Receiver: a WeakAnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a ClassRemoved
	Receiver's instance variables: 
		list: 	a WeakFinalizationList
		next: 	nil
		announcer: 	a SystemAnnouncer
		announcementClass: 	ClassRemoved
		action: 	WeakMessageSend(#classRemoved: -> a PackageTreeNautilusUI)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	WeakAnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	nil
		ex: 	UnhandledError
		copy: 	nil
		onDoCtx: 	nil
		process: 	nil
		handler: 	nil
		bottom: 	nil
		thisCtx: 	nil
	Receiver's instance variables: 
		outerContext: 	WeakAnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #asNautilusSelection
PackageTreeNautilus class>>parentOfClass:
PackageTreeNautilus(Nautilus)>>parentOfClass:
PackageTreeNautilusUI(NautilusUI)>>parentOfClass:
PackageTreeNautilusUI(NautilusUI)>>selectedClassWithoutChangingSelection:
PackageTreeNautilusUI(AbstractNautilusUI)>>selectedClass:
PackageTreeNautilusUI>>updateBothView
PackageTreeNautilusUI(AbstractNautilusUI)>>classRemoved:
WeakMessageSend>>value:
WeakMessageSend>>cull:
WeakMessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in WeakAnnouncementSubscription>>deliver:
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.	"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ 
		onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ 
				"Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
				^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority) resume.	"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: SmallInteger>>float
23 March 2015 7:08:53.961794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

SmallInteger(Object)>>doesNotUnderstand: #float
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	float
		exception: 	MessageNotUnderstood: SmallInteger>>float
		resumeValue: 	nil
	Receiver's instance variables: 
5

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'104/5 float'
		itsSelection: 	a Text for '104/5 float'
		itsSelectionString: 	'104/5 float'
	Receiver's instance variables: 
		ast: 	DoIt
	^ 104 / 5 float
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


SmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a SmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		morph: 	a TextMorphForEditView(182714368)
		selectionShowing: 	true
		model: 	a Workspace
		editingState: 	a SmalltalkEditingState


[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(500 to: 510)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


TextMorphForEditView(TextMorph)>>handleEdit:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		editBlock: 	[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :resul...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@226)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@226)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


PluggableTextMorph>>printIt
	Receiver: a PluggableTextMorph(408420352)
	Arguments and temporary variables: 
		oldEditor: 	a SmalltalkEditor
		printString: 	nil
	Receiver's instance variables: 
		bounds: 	(29.0@262.0) corner: (469.0@429.0)
		owner: 	a SystemWindow(306446336)
		submorphs: 	an Array(a ScrollBar(448266240) a TransformMorph(346030080))
		fullBounds: 	(29@262) corner: (469@429)
		color: 	Color white
		extension: 	a MorphExtension (161480704) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a Workspace
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(448266240)
		scroller: 	a TransformMorph(346030080)
		getMenuSelector: 	#codePaneMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(357564416)
		textMorph: 	a TextMorphForEditView(182714368)
		getTextSelector: 	#contents
		setTextSelector: 	#acceptContents:
		getSelectionSelector: 	nil
		hasUnacceptedEdits: 	true
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(500 to: 510)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil


[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
	Receiver: SmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		superclass: 	TextEditor
		methodDict: 	a MethodDictionary(#argAdvance:->SmalltalkEditor>>#argAdvance: #bro...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Text-Edition'
		traitComposition: 	{}
		localSelectors: 	nil
		cmdActions: 	#(#noop: #cursorHome: #noop: #noop: #cursorEnd: #noop: #noop: #noop...etc...
		shiftCmdActions: 	#(#noop: #argAdvance: #noop: #compareToClipboard: #debugIt: #m...etc...


BlockClosure>>cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		anArg: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph printIt ]
	Arguments and temporary variables: 
		firstArg: 	a PluggableTextMorph(408420352)
		secondArg: 	a PluggableTextMorph(408420352)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
		startpc: 	277
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(408420352)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(408420352)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Ctrl + P do [ :morph | morph printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph printIt ]
		name: 	#printIt
		shortcut: 	Ctrl + P
		defaultShortcut: 	Ctrl + P
		description: 	''


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


Set>>do:
	Receiver: a Set(#sendersOfIt on Ctrl + N do [ :morph | morph sendersOfIt ]
 #selectChild on Ctrl + O...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	6
		each: 	#printIt on Ctrl + P do [ :morph | morph printIt ]

	Receiver's instance variables: 
		tally: 	14
		array: 	an Array(nil #sendersOfIt on Ctrl + N do [ :morph | morph sendersOfIt ]
...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#SmalltalkEditor) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#SmalltalkEditor
		platforms: 	a Dictionary(#MacOSX->a KMStorage #Unix->a KMStorage #Windows->a KMS...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#SmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a PluggableTextMorph(408420352)
		category: 	a KMCategory
		morph: 	a PluggableTextMorph(408420352)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
		aTarget: 	aKMCategoryTarget(#SmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorphTab) aKMCategoryTarget(#MorphFocusCt...etc...
		morph: 	a PluggableTextMorph(408420352)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorphTab) aKMCategoryTa...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyM...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#TextMorphTab) aKMCate...etc...
		firstIndex: 	1
		lastIndex: 	7


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		association: 	nil
		match: 	nil
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorphTab) aKMCategoryTarget(#MorphFocusCt...etc...
		morph: 	a PluggableTextMorph(408420352)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a PluggableTextMorph(408420352)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#TextMorph) aKMCategoryTarget(#MorphFocusCtrlN...etc...
		morph: 	a TextMorphForEditView(182714368)
		directKeymaps: 	a KMCategory


TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@226)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@226)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(TextMorph)>>handleKeystroke:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		pasteUp: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@226)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@226)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a TextMorphForEditView(182714368)
	Receiver's instance variables: 
		timeStamp: 	25196813
		source: 	a HandMorph(760479744)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(45@89)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	16
		charCode: 	16
		scanCode: 	80


TextMorphForEditView(Morph)>>handleEvent:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@226)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@226)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


TextMorphForEditView(Morph)>>handleFocusEvent:
	Receiver: a TextMorphForEditView(182714368)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (419@226)
		owner: 	a TransformMorph(346030080)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (419@226)
		color: 	Color black
		extension: 	a MorphExtension (243531776) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'dario:= Persona conNombre: ''Dario'' yFecNac: ''11/16/1993''....etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	Color black
		editView: 	a PluggableTextMorph(408420352)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(182714368)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(70@279) corner: (86@295)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(182714368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(62@270) mouseOver nil nil]
		targetOffset: 	(13.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 25182976 62 270 0 0 1 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	67
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(511705088) [world]
	Arguments and temporary variables: 
		aBlock: 	[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder ha...etc...
		priorWorld: 	a WorldMorph(511705088) [world]
		priorHand: 	a HandMorph(760479744)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@658)
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(984088576) a SystemWindow(306446336) a Nauti...etc...
		fullBounds: 	(0@0) corner: (1280@658)
		color: 	(Color r: 0.937 g: 0.937 b: 0.937 alpha: 1.0)
		extension: 	a MorphExtension (552861696) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(182714368)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(511705088) [world]
	Receiver's instance variables: 
		bounds: 	(70@279) corner: (86@295)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(182714368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(62@270) mouseOver nil nil]
		targetOffset: 	(13.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 25182976 62 270 0 0 1 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a TextMorphForEditView(182714368)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(70@279) corner: (86@295)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(182714368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(62@270) mouseOver nil nil]
		targetOffset: 	(13.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 25182976 62 270 0 0 1 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(760479744)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(70@279) corner: (86@295)
		owner: 	a WorldMorph(511705088) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (114556928)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForEditView(182714368)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(62@270) mouseOver nil nil]
		targetOffset: 	(13.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 25182976 62 270 0 0 1 1)
		lastKeyScanCode: 	80
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #float
UndefinedObject>>DoIt
OpalCompiler>>evaluate
SmalltalkEditor>>evaluateSelectionAndDo:
[ 
(oldEditor := textMorph editor)
	evaluateSelectionAndDo: [ :result | 
		printString := [ result printString ]
			on: Error
			do: [ '<error in printString: try ''Inspect it'' to debug>' ].
		selectionInterval := oldEditor selectionInterval.
		textMorph installEditorToReplace: oldEditor.
		textMorph handleEdit: [ oldEditor afterSelectionInsertAndSelect: printString ].
		selectionInterval := oldEditor selectionInterval.
		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.
		self scrollSelectionIntoView ] ] in PluggableTextMorph>>printIt
TextMorphForEditView(TextMorph)>>handleEdit:
PluggableTextMorph>>printIt
[ :morph | morph printIt ] in SmalltalkEditor class>>buildSmalltalkEditorKeymappingsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
DuplicatedSlotName: Slot #'name' appeared twice in LimitedEditionProduct
23 March 2015 9:21:10.163794 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

[ :other | 
other name = current name
	ifTrue: [ 
		DuplicatedSlotName new
			oldSlot: current;
			newSlot: other;
			host: host;
			signal ] ] in FixedLayout(PointerLayout)>>checkSlotNames
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		slots: 	an OrderedCollection(price => Slot name => Slot price => Slot)
		current: 	name => Slot
		other: 	name => Slot
	Receiver's instance variables: 
		host: 	LimitedEditionProduct
		compactClassIndex: 	0
		slotScope: 	a LayoutClassScope(price => Slot name => Slot price => Slot name => ...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(price => Slot name => Slot price => Slot)
	Arguments and temporary variables: 
		aBlock: 	[ :other | 
other name = current name
	ifTrue: [ 
		DuplicatedSlotName ...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(price => Slot name => Slot price => Slot nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	3


FixedLayout(PointerLayout)>>checkSlotNames
	Receiver: a FixedLayout
	Arguments and temporary variables: 
		slots: 	an OrderedCollection(price => Slot name => Slot price => Slot)
		current: 	name => Slot
	Receiver's instance variables: 
		host: 	LimitedEditionProduct
		compactClassIndex: 	0
		slotScope: 	a LayoutClassScope(price => Slot name => Slot price => Slot name => ...etc...


FixedLayout(PointerLayout)>>checkSanity
	Receiver: a FixedLayout
	Arguments and temporary variables: 

	Receiver's instance variables: 
		host: 	LimitedEditionProduct
		compactClassIndex: 	0
		slotScope: 	a LayoutClassScope(price => Slot name => Slot price => Slot name => ...etc...


ClassModification(AbstractClassModification)>>checkSanity
	Receiver: a ClassModification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		target: 	LimitedEditionProduct
		layout: 	a FixedLayout
		propagations: 	an OrderedCollection()
		newClass: 	nil
		ownSlotStart: 	nil
		superclass: 	Product
		additions: 	#()
		removals: 	#()
		changes: 	an IdentityDictionary()
		subclassSlotOffset: 	nil
		slotShift: 	nil
		methodModification: 	nil
		copies: 	an IdentityDictionary()
		traitComposition: 	{}
		sharedVariables: 	''
		sharedPools: 	''


ClassModification(AbstractClassModification)>>computeChange
	Receiver: a ClassModification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		target: 	LimitedEditionProduct
		layout: 	a FixedLayout
		propagations: 	an OrderedCollection()
		newClass: 	nil
		ownSlotStart: 	nil
		superclass: 	Product
		additions: 	#()
		removals: 	#()
		changes: 	an IdentityDictionary()
		subclassSlotOffset: 	nil
		slotShift: 	nil
		methodModification: 	nil
		copies: 	an IdentityDictionary()
		traitComposition: 	{}
		sharedVariables: 	''
		sharedPools: 	''


ClassModification>>computeChange
	Receiver: a ClassModification
	Arguments and temporary variables: 

	Receiver's instance variables: 
		target: 	LimitedEditionProduct
		layout: 	a FixedLayout
		propagations: 	an OrderedCollection()
		newClass: 	nil
		ownSlotStart: 	nil
		superclass: 	Product
		additions: 	#()
		removals: 	#()
		changes: 	an IdentityDictionary()
		subclassSlotOffset: 	nil
		slotShift: 	nil
		methodModification: 	nil
		copies: 	an IdentityDictionary()
		traitComposition: 	{}
		sharedVariables: 	''
		sharedPools: 	''


ClassModification(AbstractClassModification)>>layout:
	Receiver: a ClassModification
	Arguments and temporary variables: 
		aLayout: 	a FixedLayout
	Receiver's instance variables: 
		target: 	LimitedEditionProduct
		layout: 	a FixedLayout
		propagations: 	an OrderedCollection()
		newClass: 	nil
		ownSlotStart: 	nil
		superclass: 	Product
		additions: 	#()
		removals: 	#()
		changes: 	an IdentityDictionary()
		subclassSlotOffset: 	nil
		slotShift: 	nil
		methodModification: 	nil
		copies: 	an IdentityDictionary()
		traitComposition: 	{}
		sharedVariables: 	''
		sharedPools: 	''


ClassModification>>layoutClass:slots:compactClassIndex:
	Receiver: a ClassModification
	Arguments and temporary variables: 
		layoutClass: 	FixedLayout
		slotArray: 	an Array(price => Slot name => Slot)
		compactClassIndex: 	0
		parentLayout: 	a FixedLayout
		newScope: 	a LayoutClassScope(price => Slot name => Slot price => Slot name => S...etc...
		newLayout: 	a FixedLayout
	Receiver's instance variables: 
		target: 	LimitedEditionProduct
		layout: 	a FixedLayout
		propagations: 	an OrderedCollection()
		newClass: 	nil
		ownSlotStart: 	nil
		superclass: 	Product
		additions: 	#()
		removals: 	#()
		changes: 	an IdentityDictionary()
		subclassSlotOffset: 	nil
		slotShift: 	nil
		methodModification: 	nil
		copies: 	an IdentityDictionary()
		traitComposition: 	{}
		sharedVariables: 	''
		sharedPools: 	''


ClassModification class>>modify:extend:withLayoutType:slots:sharedVariables:sharedPools:traitComposition:compactClassIndex:
	Receiver: ClassModification
	Arguments and temporary variables: 
		aClass: 	LimitedEditionProduct
		aSuperclass: 	Product
		layoutClass: 	FixedLayout
		someSlots: 	an Array(price => Slot name => Slot)
		someSharedVariables: 	''
		someSharedPools: 	''
		aTraitComposition: 	{}
		compactClassIndex: 	0
	Receiver's instance variables: 
		superclass: 	AbstractClassModification
		methodDict: 	a MethodDictionary(#additions:->ClassModification>>#additions: #bui...etc...
		format: 	162
		layout: 	a FixedLayout
		instanceVariables: 	#(#ownSlotStart #superclass #additions #removals #changes #s...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ClassModification
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Slot-ClassBuilder'
		traitComposition: 	{}
		localSelectors: 	nil


SlotClassBuilder>>build
	Receiver: a SlotClassBuilder
	Arguments and temporary variables: 
		oldClass: 	LimitedEditionProduct
		metaChange: 	a ClassModification
		classChange: 	nil
	Receiver's instance variables: 
		installer: 	a PharoClassInstaller
		oldClasses: 	an OrderedCollection()
		newClasses: 	an OrderedCollection()
		classSlots: 	#()
		category: 	'Practica1Obj2'
		superclass: 	Product
		name: 	#LimitedEditionProduct
		layoutClass: 	FixedLayout
		slots: 	an Array(price => Slot name => Slot)
		traitComposition: 	{}
		classTraitComposition: 	{}
		result: 	LimitedEditionProduct
		sharedPoolsString: 	''
		sharedVariablesString: 	''


PharoClassInstaller class(AbstractClassInstaller class)>>make:
	Receiver: PharoClassInstaller
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	superclass: superClass;
	name: name;
	layoutClas...etc...
		builder: 	a SlotClassBuilder
	Receiver's instance variables: 
		superclass: 	AbstractClassInstaller
		methodDict: 	a MethodDictionary(#basicClassDefinitionChangedFrom:to:using:->Phar...etc...
		format: 	138
		layout: 	a FixedLayout
		instanceVariables: 	#('environment' 'instanceModification' 'methodUpdateStrategy...etc...
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoClassInstaller
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Slot-ClassBuilder'
		traitComposition: 	{}
		localSelectors: 	nil


OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		name: 	#LimitedEditionProduct
		environment: 	a SystemDictionary(lots of globals)
		superClass: 	Product
		type: 	#normal
		instanceVariablesString: 	'price name'
		classVariablesString: 	''
		sharedPoolsString: 	''
		category: 	'Practica1Obj2'
	Receiver's instance variables: 
an OldClassBuilderAdapter

OldClassBuilderAdapter>>superclass:subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: an OldClassBuilderAdapter
	Arguments and temporary variables: 
		newSuper: 	Product
		t: 	#LimitedEditionProduct
		f: 	'price name'
		d: 	''
		s: 	''
		cat: 	'Practica1Obj2'
	Receiver's instance variables: 
an OldClassBuilderAdapter

Product class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: Product
	Arguments and temporary variables: 
		t: 	#LimitedEditionProduct
		f: 	'price name'
		d: 	''
		s: 	''
		cat: 	'Practica1Obj2'
		class: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#getName->Product>>#getName #getPrice->Product>>...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#price #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Product
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica1Obj2
		traitComposition: 	{}
		localSelectors: 	nil


Product class(Class)>>subclass:instanceVariableNames:classVariableNames:category:
	Receiver: Product
	Arguments and temporary variables: 
		aSubclassSymbol: 	#LimitedEditionProduct
		instVarNames: 	'price name'
		classVarNames: 	''
		aCategorySymbol: 	'Practica1Obj2'
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#getName->Product>>#getName #getPrice->Product>>...etc...
		format: 	134
		layout: 	a FixedLayout
		instanceVariables: 	#(#price #name)
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Product
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Practica1Obj2
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Product
		subclass: #LimitedEditionProduct
		instanceVariableNames...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil
		useFaultyForParsing: 	false


PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'Product subclass: #LimitedEditionProduct
	instanceVariableNames: ''pr...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
		aClass: 	LimitedEditionProduct
		oldClass: 	Object
		class: 	nil
		newClassName: 	'LimitedEditionProduct'
		defTokens: 	an OrderedCollection('Product' 'subclass:' '#LimitedEditionProduct' ...etc...
		keywdIx: 	2
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	LimitedEditionProduct
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(LimitedEditionProduct->true ShoppingCart->false ...etc...
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. LimitedEditionProduct. Mascota. MuchasPersonas. Persona...etc...
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aString: 	'Product subclass: #LimitedEditionProduct
	instanceVariableNames: ''pr...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	LimitedEditionProduct
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(LimitedEditionProduct->true ShoppingCart->false ...etc...
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. LimitedEditionProduct. Mascota. MuchasPersonas. Persona...etc...
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


ClassOrMethodDefinitionAcceptor>>acceptInstanceSide:notifying:
	Receiver: a ClassOrMethodDefinitionAcceptor
	Arguments and temporary variables: 
		isClassDefinition: 	true
		source: 	'Product subclass: #LimitedEditionProduct
	instanceVariableNames: ''pri...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


ClassOrMethodDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassOrMethodDefinitionAcceptor
	Arguments and temporary variables: 
		source: 	'Product subclass: #LimitedEditionProduct
	instanceVariableNames: ''pri...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		model: 	a PackageTreeNautilusUI


PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aText: 	a Text for 'Product subclass: #LimitedEditionProduct
	instanceVariableNa...etc...
		aController: 	a PluggableTextMorphWithLimits(87818240)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	LimitedEditionProduct
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(a PackageTreePackageSelection->true a RPackage(...etc...
		classesSelection: 	a Dictionary(LimitedEditionProduct->true ShoppingCart->false ...etc...
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{Equipo. LimitedEditionProduct. Mascota. MuchasPersonas. Persona...etc...
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a ClassOrMethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'Product subclass: #LimitedEditionProduct
	instanceVar...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(8 to: 7)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


BlockClosure>>ensure:
	Receiver: [ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perfor...etc...
	Arguments and temporary variables: 
		aBlock: 	[ unstyledAcceptText := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInMod...etc...
		startpc: 	65
		numArgs: 	0


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		acceptedText: 	a Text for 'Product subclass: #LimitedEditionProduct
	instanceVar...etc...
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(8 to: 7)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		ok: 	nil
		saveSelection: 	(8 to: 7)
		saveScrollerOffset: 	(-3@0)
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(8 to: 7)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits>>acceptBasic
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 
		saveSelection: 	nil
		saveScrollerOffset: 	nil
	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(8 to: 7)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
	Receiver: a PluggableTextMorphWithLimits(87818240)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(498.0@319.0) corner: (1224.0@568.0)
		owner: 	a MultipleMethodsEditor(1023934464)
		submorphs: 	an Array(an AlphaImageMorph(967573504) a TransformMorph(611844096))
		fullBounds: 	(498@319) corner: (1224@568)
		color: 	Color white
		extension: 	a MorphExtension (847773696) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.784 g: 0.784 b: 0.784 alpha: 1.0)
		model: 	a PackageTreeNautilusUI
		open: 	false
		accessor: 	nil
		scrollBar: 	a ScrollBar(135528448)
		scroller: 	a TransformMorph(611844096)
		getMenuSelector: 	#sourceCodeMenu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(918814720)
		textMorph: 	a TextMorphForEditView(881065984)
		getTextSelector: 	#sourceCodeFrom:
		setTextSelector: 	#compileSource:notifying:
		getSelectionSelector: 	#contentsSelectionFrom:
		hasUnacceptedEdits: 	false
		askBeforeDiscardingEdits: 	true
		selectionInterval: 	(8 to: 7)
		hasEditingConflicts: 	false
		acceptAction: 	nil
		getColorSelector: 	nil
		unstyledAcceptText: 	nil
		styler: 	a SHTextStylerST80
		autoAccept: 	nil
		enabled: 	true
		getEnabledSelector: 	nil
		highlights: 	an OrderedCollection()
		acceptOnFocusChange: 	nil
		selectionColor: 	nil
		alwaysAccept: 	nil
		changedAction: 	nil
		doubleClickSelector: 	nil
		setSelectionSelector: 	nil
		alertLimit: 	nil
		locked: 	false
		warningLimit: 	-1
		method: 	nil
		lockIcon: 	an AlphaImageMorph(967573504)
		canLockChangeSelector: 	#canChangeLockFor:
		lockSelector: 	#lockTextArea:from:


TextMorphForEditView>>acceptContents
	Receiver: a TextMorphForEditView(881065984)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (718@66)
		owner: 	a TransformMorph(611844096)
		submorphs: 	#()
		fullBounds: 	(0@0) corner: (718@66)
		color: 	Color black
		extension: 	a MorphExtension (935854080) [other:  (kmDispatcher -> a KMDispatche...etc...
		borderWidth: 	0
		borderColor: 	Color black
		textStyle: 	a TextStyle Bitmap DejaVu Sans 9
		text: 	a Text for 'Product subclass: #LimitedEditionProduct
	instanceVariableNam...etc...
		wrapFlag: 	true
		paragraph: 	a Paragraph
		editor: 	a SmalltalkEditor
		container: 	nil
		predecessor: 	nil
		successor: 	nil
		backgroundColor: 	nil
		margins: 	(0@0) corner: (0@0)
		defaultColor: 	a TextColor code: (Color r: 0.0 g: 0.0 b: 0.5 alpha: 1.0)
		editView: 	a PluggableTextMorphWithLimits(87818240)
		acceptOnCR: 	false
		autoAccept: 	false
		acceptOnFocusChange: 	false
		selectionColor: 	nil


[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
	Receiver: TextMorph
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		morph: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		superclass: 	BorderedMorph
		methodDict: 	a MethodDictionary(size 204)
		format: 	168
		layout: 	a FixedLayout
		instanceVariables: 	#(#textStyle #text #wrapFlag #paragraph #editor #container #...etc...
		organization: 	a ClassOrganization
		subclasses: 	{StringMorphEditor. TextMorphForEditView. GrowlMorph}
		name: 	#TextMorph
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Base-Basic'
		traitComposition: 	TAbleToRotate
		localSelectors: 	a Set(#editorClass #setTextStyle: #setFirstCharacter: #margins:...etc...
		announcer: 	nil


BlockClosure>>cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		anArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :morph | morph acceptContents ]
	Arguments and temporary variables: 
		firstArg: 	a TextMorphForEditView(881065984)
		secondArg: 	a TextMorphForEditView(881065984)
		thirdArg: 	[keystroke '<Ctrl-s>']
	Receiver's instance variables: 
		outerContext: 	TextMorph class>>buildTextEditorKeymapsOn:
		startpc: 	80
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#TextMorph)
	Arguments and temporary variables: 
		aKeymap: 	#accept on Ctrl + S do [ :morph | morph acceptContents ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
	Receiver's instance variables: 
		target: 	a TextMorphForEditView(881065984)
		category: 	a KMCategory
		morph: 	a TextMorphForEditView(881065984)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		l: 	aKMCategoryTarget(#TextMorph)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		listeners: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #accept on Ctrl + S do [ :morph | morph acceptContents ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-s>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#TextMorph) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :morph | morph acceptContents ]
		name: 	#accept
		shortcut: 	Ctrl + S
		defaultShortcut: 	Ctrl + S
		description: 	''



--- The full stack ---
[ :other | 
other name = current name
	ifTrue: [ 
		DuplicatedSlotName new
			oldSlot: current;
			newSlot: other;
			host: host;
			signal ] ] in FixedLayout(PointerLayout)>>checkSlotNames
OrderedCollection>>do:
FixedLayout(PointerLayout)>>checkSlotNames
FixedLayout(PointerLayout)>>checkSanity
ClassModification(AbstractClassModification)>>checkSanity
ClassModification(AbstractClassModification)>>computeChange
ClassModification>>computeChange
ClassModification(AbstractClassModification)>>layout:
ClassModification>>layoutClass:slots:compactClassIndex:
ClassModification class>>modify:extend:withLayoutType:slots:sharedVariables:sharedPools:traitComposition:compactClassIndex:
SlotClassBuilder>>build
PharoClassInstaller class(AbstractClassInstaller class)>>make:
OldClassBuilderAdapter>>name:inEnvironment:subclassOf:type:instanceVariableNames:classVariableNames:poolDictionaries:category:
OldClassBuilderAdapter>>superclass:subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
Product class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
Product class(Class)>>subclass:instanceVariableNames:classVariableNames:category:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
PackageTreeNautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
PackageTreeNautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
ClassOrMethodDefinitionAcceptor>>acceptInstanceSide:notifying:
ClassOrMethodDefinitionAcceptor>>accept:notifying:
PackageTreeNautilusUI(NautilusUI)>>compileSource:notifying:
[ 
^ setTextSelector isNil
	or: [ 
		setTextSelector numArgs = 2
			ifTrue: [ model perform: setTextSelector with: acceptedText with: self ]
			ifFalse: [ model perform: setTextSelector with: acceptedText ] ] ] in PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
BlockClosure>>ensure:
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptTextInModel
PluggableTextMorphWithLimits(PluggableTextMorph)>>acceptBasic
PluggableTextMorphWithLimits>>acceptBasic
PluggableTextMorphWithLimits(PluggableTextMorph)>>accept
TextMorphForEditView>>acceptContents
[ :morph | morph acceptContents ] in TextMorph class>>buildTextEditorKeymapsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget verifyMatchWith: anEventBuffer notifying: self thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
TextMorphForEditView(Morph)>>dispatchKeystrokeForEvent:
TextMorphForEditView(TextMorph)>>handleKeystroke:
KeyboardEvent>>sentTo:
TextMorphForEditView(Morph)>>handleEvent:
TextMorphForEditView(Morph)>>handleFocusEvent:
[ 
ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[ :h | 
ActiveHand := h.
h processEvents.
ActiveHand := nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[ 
World doOneCycle.
Processor yield.
false ] in MorphicUIManager>>spawnNewProcess
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Debug CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
14 June 2015 11:14:29.20337 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


CiberTest(TestCase)>>performTest
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


[ 
self setUp.
self performTest ] in CiberTest(TestCase)>>runCase
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CiberTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


CiberTest(TestCase)>>runCase
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver's instance variables: 
		timeStamp: 	2015-06-14T23:14:29.11437-03:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase anno...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	70
		numArgs: 	0


TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver's instance variables: 
		timeStamp: 	2015-06-14T23:14:29.11437-03:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


CiberTest(TestCase)>>run:
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
		each: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self chang...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>run:
		startpc: 	49
		numArgs: 	0


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


TestSuite>>run
	Receiver: a TestSuite
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


[ value run ] in [ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aMethod: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		context: 	CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
		process: 	a Process in CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstal...etc...
		value: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	LimitedEditionProduct
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(Tests->true )
		classesSelection: 	a Dictionary(CiberTest->true ComputadoraTest->false )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{CiberTest. ComputadoraTest. DiscoTest. MotherboardTest. PedidoT...etc...
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


BlockClosure>>ensure:
	Receiver: [ value run ]
	Arguments and temporary variables: 
		aBlock: 	[ 
UIManager default uiProcess == Processor activeProcess
	ifFalse: [ P...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProce...etc...
		startpc: 	166
		numArgs: 	0


[ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aMethod: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		context: 	CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
		process: 	a Process in CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstal...etc...
		value: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	LimitedEditionProduct
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(Tests->true )
		classesSelection: 	a Dictionary(CiberTest->true ComputadoraTest->false )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	nil
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{CiberTest. ComputadoraTest. DiscoTest. MotherboardTest. PedidoT...etc...
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)



--- The full stack ---
CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
CiberTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in CiberTest(TestCase)>>runCase
BlockClosure>>ensure:
CiberTest(TestCase)>>runCase
[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CiberTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
BlockClosure>>ensure:
TestSuite>>run:
TestSuite>>run
[ value run ] in [ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
BlockClosure>>ensure:
[ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Debug CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
14 June 2015 11:19:11.22737 pm

VM: Win32 - IX86 - 6.1 - NBCoInterpreter NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
NBCogit NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 May 15 2014
https://github.com/pharo-project/pharo-vm.git Commit: ed4a4f59208968a21d82fd2406f75c2c4de558b2 Date: 2014-05-15 18:23:04 +0200 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #14826

Image: Pharo3.0 [Latest update: #30856]

CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


CiberTest(TestCase)>>performTest
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


[ 
self setUp.
self performTest ] in CiberTest(TestCase)>>runCase
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


BlockClosure>>ensure:
	Receiver: [ 
self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ 
self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CiberTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


CiberTest(TestCase)>>runCase
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver's instance variables: 
		timeStamp: 	2015-06-14T23:19:11.20837-03:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase anno...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	70
		numArgs: 	0


TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver's instance variables: 
		timeStamp: 	2015-06-14T23:19:11.20837-03:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


CiberTest(TestCase)>>run:
	Receiver: CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		expectedFails: 	nil
		ciber: 	a Ciber
		unaCompuCualquiera: 	a Computadora
		word: 	a Programa
		photoshop: 	a Programa
		otraCompu: 	a Computadora
		pharo3: 	a Programa
		autocad: 	a Programa
		firefox: 	a Programa


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
		each: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado n...etc...
		firstIndex: 	1
		lastIndex: 	1


[ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


BlockClosure>>ensure:
	Receiver: [ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self chang...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>run:
		startpc: 	49
		numArgs: 	0


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


TestSuite>>run
	Receiver: a TestSuite
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		dependents: 	nil
		tests: 	an OrderedCollection(CiberTest>>#test05ElCiberRetornaLaCompuConUnProgram...etc...
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	nil


[ value run ] in [ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aMethod: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		context: 	CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
		process: 	a Process in CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstal...etc...
		value: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	LimitedEditionProduct
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(Tests->true )
		classesSelection: 	a Dictionary(CiberTest->true ComputadoraTest->false )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	a PluggableTextMorph(246415360)
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{CiberTest. ComputadoraTest. DiscoTest. MotherboardTest. PedidoT...etc...
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)


BlockClosure>>ensure:
	Receiver: [ value run ]
	Arguments and temporary variables: 
		aBlock: 	[ 
UIManager default uiProcess == Processor activeProcess
	ifFalse: [ P...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProce...etc...
		startpc: 	166
		numArgs: 	0


[ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
	Receiver: a PackageTreeNautilusUI
	Arguments and temporary variables: 
		aMethod: 	CiberTest>>#test05ElCiberRetornaLaCompuConUnProgramaInstalado
		context: 	CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
		process: 	a Process in CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstal...etc...
		value: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a NautilusWindow(...etc...
		model: 	a PackageTreeNautilus
		window: 	a NautilusWindow(745275392)
		hierarchyClass: 	LimitedEditionProduct
		cachedHierarchy: 	a SortHierarchically
		sourceTextArea: 	a PluggableTextMorphWithLimits(87818240)
		groupsSelection: 	a Dictionary()
		packagesSelection: 	a Dictionary(Tests->true )
		classesSelection: 	a Dictionary(CiberTest->true ComputadoraTest->false )
		list: 	a MorphTreeMorph(924844032)
		list2: 	a PluggableIconListMorph(930349056)
		sourceCodePanel: 	a PanelMorph(981729280)
		commentTextArea: 	a PluggableTextMorph(246415360)
		currentDisplayChoice: 	#SourceCode
		sourceTextAreaLimit: 	350
		sourceCodeContainer: 	a PanelMorph(236716032)
		list2Elements: 	{CiberTest. ComputadoraTest. DiscoTest. MotherboardTest. PedidoT...etc...
		listElements: 	nil
		shouldUpdateTitle: 	true
		testSemaphore: 	a Semaphore()
		sourceTextAreas: 	an OrderedCollection(a PluggableTextMorphWithLimits(87818240)-...etc...
		multipleMethodsEditor: 	a MultipleMethodsEditor(1023934464)
		contentSelection: 	nil
		acceptor: 	a MethodDefinitionAcceptor
		classifier: 	a MethodClassifier
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(172752896)



--- The full stack ---
CiberTest>>test05ElCiberRetornaLaCompuConUnProgramaInstalado
CiberTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in CiberTest(TestCase)>>runCase
BlockClosure>>ensure:
CiberTest(TestCase)>>runCase
[ 
aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCase.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CiberTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
OrderedCollection>>do:
[ 
self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>run:
BlockClosure>>ensure:
TestSuite>>run:
TestSuite>>run
[ value run ] in [ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
BlockClosure>>ensure:
[ :value | 
[ value run ]
	ensure: [ 
		UIManager default uiProcess == Processor activeProcess
			ifFalse: [ Processor activeProcess terminate ] ] ] in PackageTreeNautilusUI(NautilusUI)>>debugTest:
-------------------------------------------------------------------------------

